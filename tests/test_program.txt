;===============================================
; Test Name: Comprehensive ISA Feature Test
; Description: Tests all major ISA features including:
;   - Register operations (MOV)
;   - Memory operations (LOAD)
;   - Arithmetic (ADD, SUB, INC, DEC)
;   - Logical (NOT, AND, OR, XOR)
;   - Shifts (SHL, SHR)
;   - Comparisons (CMP, TEST)
;   - Control flow (JMP, JZ, JNZ)
;   - Cache behavior
;
; Expected Results:
;   - Final register values:
;     * eax = 0 (counted down from 10)
;     * ebx = 6 (incremented then decremented)
;     * ecx = 12 (loop counter)
;     * edx = 12 (after AND operations)
;     * esi = 123 (from memory)
;     * edi = 15 (after AND operations)
;   - Cache performance:
;     * Should show hits for repeated memory access
;     * Should demonstrate L1/L2 interaction
;===============================================

; Initialize registers
MOV eax #5     ; eax = 5 (loop counter)
MOV ebx #42    ; ebx = 42
MOV ecx #0     ; ecx = 0 (will count iterations)
MOV edx #10    ; edx = 10 (for arithmetic)
MOV esi #42    ; esi = 42 (0b101010)
MOV edi #15    ; edi = 15 (0b001111)

; Verify initial register values
CMP eax #5     ; Verify eax = 5
CMP ebx #42    ; Verify ebx = 42
CMP ecx #0     ; Verify ecx = 0
CMP edx #10    ; Verify edx = 10
CMP esi #42    ; Verify esi = 42
CMP edi #15    ; Verify edi = 15

; Store some values in memory
MOV [100] #42  ; Memory[100] = 42
MOV [104] #123 ; Memory[104] = 123
MOV [108] #255 ; Memory[108] = 255

; Verify memory values
LOAD eax [100] ; Load Memory[100]
CMP eax #42    ; Verify Memory[100] = 42
LOAD eax [104] ; Load Memory[104]
CMP eax #123   ; Verify Memory[104] = 123
LOAD eax [108] ; Load Memory[108]
CMP eax #255   ; Verify Memory[108] = 255

; Reset eax for next operations
MOV eax #5

; Load values from memory to demonstrate cache
LOAD edx [100] ; edx = 42
LOAD esi [104] ; esi = 123
LOAD edi [108] ; edi = 255

; Verify loaded values
CMP edx #42    ; Verify edx = 42
CMP esi #123   ; Verify esi = 123
CMP edi #255   ; Verify edi = 255

; Memory ops
MOV [100] ebx
LOAD ebx [100]
CMP ebx #42    ; Verify ebx = 42

; Arithmetic
ADD edx #5     ; edx = 47
CMP edx #47    ; Verify edx = 47
SUB edx #10    ; edx = 37
CMP edx #37    ; Verify edx = 37
INC edx        ; edx = 38
CMP edx #38    ; Verify edx = 38
DEC edx        ; edx = 37
CMP edx #37    ; Verify edx = 37

; Bitwise
OR esi #21     ; esi = 127
CMP esi #127   ; Verify esi = 127
AND edi esi    ; edi = 15
CMP edi #15    ; Verify edi = 15
XOR esi #21    ; esi = 106
CMP esi #106   ; Verify esi = 106
NOT edi        ; edi = -16
CMP edi #-16   ; Verify edi = -16

; Test comparison operations
MOV esi #42    ; esi = 42 (for comparison)
MOV edi #50    ; edi = 50 (for comparison)
CMP esi edi    ; esi < edi, so esi = 1
CMP esi #1     ; Verify esi = 1
CMP edi esi    ; edi > esi, so edi = 0
CMP edi #0     ; Verify edi = 0
CMP esi #50    ; esi < 50, so esi = 1
CMP esi #1     ; Verify esi = 1
CMP esi #40    ; esi > 40, so esi = 0
CMP esi #0     ; Verify esi = 0

; Test bit testing
MOV esi #10    ; esi = 10 (0b1010)
MOV edi #2     ; edi = 2  (0b0010)
TEST esi edi   ; esi = 10 (0b1010), edi = 2 (0b0010)
               ; Result = 1 (bit 1 is set in both)
CMP esi #10    ; Verify esi = 10
CMP edi #2     ; Verify edi = 2

; Test shifts
MOV ebx #1     ; ebx = 1
SHL ebx #1     ; ebx = 2
CMP ebx #2     ; Verify ebx = 2
SHL ebx #2     ; ebx = 8
CMP ebx #8     ; Verify ebx = 8
SHR ebx #1     ; ebx = 4
CMP ebx #4     ; Verify ebx = 4
SHR ebx #2     ; ebx = 1
CMP ebx #1     ; Verify ebx = 1

; Test memory shifts
MOV [200] #8   ; Memory[200] = 8
SHL [200] #2   ; Memory[200] = 32
LOAD eax [200] ; Load Memory[200]
CMP eax #32    ; Verify Memory[200] = 32
SHR [200] #1   ; Memory[200] = 16
LOAD eax [200] ; Load Memory[200]
CMP eax #16    ; Verify Memory[200] = 16

; Control flow - FIXED to avoid infinite loop
MOV eax #3     ; Set a small counter for the loop
loop:
    ADD ecx #1
    SUB eax #1
    JNZ loop

; Final state check
JZ done        ; If eax == 0, we're done
JMP error      ; Otherwise, something went wrong

done:
HALT

error:
MOV eax #0     ; Set error code
HALT

;===============================================
; Cache Behavior Test with Debug Output
;===============================================

; Initial writes to memory
MOV [100] #42   ; Write 42 to address 100
PRINT_CACHE     ; Show cache state after first write

MOV [104] #123  ; Write 123 to address 104
PRINT_CACHE     ; Show cache state after second write

MOV [108] #255  ; Write 255 to address 108
PRINT_CACHE     ; Show cache state after third write

; Read operations to test cache hits
LOAD eax [100]  ; Should be in L1 cache
PRINT_CACHE     ; Show if it was a hit

LOAD ebx [104]  ; Should be in L1 cache
PRINT_CACHE     ; Show if it was a hit

LOAD ecx [108]  ; Should be in L1 cache
PRINT_CACHE     ; Show if it was a hit

; Write to a new location to test eviction
MOV [112] #99   ; This might cause eviction
PRINT_CACHE     ; Show cache state after potential eviction

; Verify final memory state
LOAD eax [100]  ; Load Memory[100]
CMP eax #42     ; Verify Memory[100] = 42
LOAD eax [104]  ; Load Memory[104]
CMP eax #123    ; Verify Memory[104] = 123
LOAD eax [108]  ; Load Memory[108]
CMP eax #255    ; Verify Memory[108] = 255
LOAD eax [112]  ; Load Memory[112]
CMP eax #99     ; Verify Memory[112] = 99

; Test cache eviction with multiple writes
MOV [116] #111  ; Write to a new address
PRINT_CACHE     ; Show cache state after eviction
LOAD eax [116]  ; Load the new value
CMP eax #111    ; Verify Memory[116] = 111

; Test cache hit after eviction
LOAD eax [100]  ; Should be a miss if evicted
PRINT_CACHE     ; Show if it was a hit or miss
CMP eax #42     ; Verify Memory[100] = 42

HALT
