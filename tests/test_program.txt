; Enhanced Test Program with Comprehensive Cache and Memory Operations
; Demonstrates: Memory operations, Cache interactions, Arithmetic, Bitwise operations,
; Shifts, Comparisons, Control flow, and Cache eviction patterns

; Initialize registers with test values
MOV eax #42    ; Test value 1
MOV ebx #123   ; Test value 2
MOV ecx #255   ; Test value 3
MOV edx #0     ; Test value 4
MOV esi #16    ; Test value 5
MOV edi #99    ; Test value 6

; Verify initial register values
CMP eax #42    ; Verify eax = 42
CMP ebx #123   ; Verify ebx = 123
CMP ecx #255   ; Verify ecx = 255
CMP edx #0     ; Verify edx = 0
CMP esi #16    ; Verify esi = 16
CMP edi #99    ; Verify edi = 99

; Test 1: Basic Memory Operations with Cache Interaction
MOV [100] eax  ; Write 42 to Memory[100] - Should miss L1, miss L2
LOAD eax [100] ; Read from Memory[100] - Should hit L1
CMP eax #42    ; Verify Memory[100] = 42

MOV [104] ebx  ; Write 123 to Memory[104] - Should miss L1, miss L2
LOAD ebx [104] ; Read from Memory[104] - Should hit L1
CMP ebx #123   ; Verify Memory[104] = 123

; Test 2: Cache Line Boundary Test
LOAD eax [108]  ; Load current value at [108]
CMP eax #0      ; Verify current value
MOV [108] ecx   ; Write 255 to Memory[108]
LOAD eax [108]  ; Load value after write
CMP eax #255    ; Verify new value
MOV [112] edx   ; Write 0 to Memory[112]
LOAD ecx [108]  ; Read from Memory[108]
LOAD edx [112]  ; Read from Memory[112]
CMP ecx #255    ; Verify Memory[108] = 255
CMP edx #0      ; Verify Memory[112] = 0

; Test 3: Cache Set Conflict Test
MOV [116] esi  ; Write 16 to Memory[116]
MOV [120] edi  ; Write 99 to Memory[120]
LOAD esi [116] ; Read from Memory[116]
LOAD edi [120] ; Read from Memory[120]
CMP esi #16    ; Verify Memory[116] = 16
CMP edi #99    ; Verify Memory[120] = 99

; Test 4: Memory Shifts with Cache Interaction
SHL [100] #2   ; Shift Memory[100] left by 2 (42 -> 168)
LOAD eax [100] ; Read shifted value
CMP eax #168   ; Verify Memory[100] = 168

SHR [104] #1   ; Shift Memory[104] right by 1 (123 -> 61)
LOAD ebx [104] ; Read shifted value
CMP ebx #61    ; Verify Memory[104] = 61

; Test 5: Arithmetic Operations with Memory
LOAD ecx [108] ; Load Memory[108] into ecx
ADD ecx #10    ; Add 10 to ecx (255 -> 265)
MOV [108] ecx  ; Store result back to Memory[108]
LOAD ecx [108] ; Read result
CMP ecx #265   ; Verify Memory[108] = 265

LOAD edx [112] ; Load Memory[112] into edx
SUB edx #5     ; Subtract 5 from edx (0 -> -5)
MOV [112] edx  ; Store result back to Memory[112]
LOAD edx [112] ; Read result
CMP edx #-5    ; Verify Memory[112] = -5

; Test 6: Bitwise Operations with Memory
LOAD esi [116] ; Load Memory[116] into esi
AND esi #240   ; AND esi with 240 (16 -> 16)
MOV [116] esi  ; Store result back to Memory[116]
LOAD esi [116] ; Read result
CMP esi #16    ; Verify Memory[116] = 16

LOAD edi [120] ; Load Memory[120] into edi
OR edi #15     ; OR edi with 15 (99 -> 111)
MOV [120] edi  ; Store result back to Memory[120]
LOAD edi [120] ; Read result
CMP edi #111   ; Verify Memory[120] = 111

; Test 7: Cache Eviction Pattern Test
MOV [124] #200 ; Write to new address - Should cause eviction
LOAD eax [124] ; Read new value
CMP eax #200   ; Verify Memory[124] = 200

; Test 8: Memory Consistency After Eviction
LOAD ebx [100] ; Read from evicted address - Should miss
CMP ebx #168   ; Verify Memory[100] still = 168

; Test 9: Rapid Cache Access Pattern
MOV [128] #300 ; Write to new address
LOAD ecx [128] ; Read immediately - Should hit
CMP ecx #300   ; Verify Memory[128] = 300

; Test 10: Cache Line Boundary Stress
MOV [132] #400 ; Write to new address
MOV [136] #500 ; Write to adjacent address
LOAD edx [132] ; Read first address
LOAD esi [136] ; Read second address
CMP edx #400   ; Verify Memory[132] = 400
CMP esi #500   ; Verify Memory[136] = 500

; Test 11: Comparison Operations
CMP [100] #168 ; Compare Memory[100] with 168
CMP [104] #61  ; Compare Memory[104] with 61
CMP [108] #265 ; Compare Memory[108] with 265
CMP [112] #-5  ; Compare Memory[112] with -5

; Test 12: Control Flow with Cache Interaction
MOV eax #3     ; Set counter for loop
LOOP_START:
    DEC eax    ; Decrement counter
    CMP eax #0 ; Check if counter is 0
    JNZ LOOP_START ; Jump if not zero

; Test 13: Cache Set Conflict Stress
MOV [140] #600 ; Write to new address
MOV [144] #700 ; Write to new address
MOV [148] #800 ; Write to new address
LOAD eax [140] ; Read first address
LOAD ebx [144] ; Read second address
LOAD ecx [148] ; Read third address
CMP eax #600   ; Verify Memory[140] = 600
CMP ebx #700   ; Verify Memory[144] = 700
CMP ecx #800   ; Verify Memory[148] = 800

; Test 14: Memory-Cache Coherence
MOV [152] #900 ; Write to new address
LOAD edx [152] ; Read immediately - Should hit
CMP edx #900   ; Verify Memory[152] = 900

; Test 15: Final Memory State Verification
LOAD eax [100] ; Load Memory[100]
CMP eax #168   ; Verify Memory[100] = 168
LOAD eax [104] ; Load Memory[104]
CMP eax #61    ; Verify Memory[104] = 61
LOAD eax [108] ; Load Memory[108]
CMP eax #265   ; Verify Memory[108] = 265
LOAD eax [112] ; Load Memory[112]
CMP eax #-5    ; Verify Memory[112] = -5
LOAD eax [116] ; Load Memory[116]
CMP eax #16    ; Verify Memory[116] = 16
LOAD eax [120] ; Load Memory[120]
CMP eax #111   ; Verify Memory[120] = 111
